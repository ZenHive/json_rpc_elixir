defmodule JsonRpc.ApiCreator do
  @default_retries 2
  @default_timeout 5_000
  @default_retry_on_timeout? false
  @default_time_between_retries 200

  @moduledoc """
  ## Description

  Defines a use macro for creating JSON-RPC APIs by automatically generating functions
  that map to JSON-RPC methods. It handles the boilerplate of making RPC calls and
  parsing responses.

  ## Basic Usage

  ```elixir
  defmodule MyApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        retries: 2,
        timeout: :timer.seconds(5)
        retry_on_timeout?: false,
        time_between_retries: 200,
        response_type: User.t(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            %{id: id}
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      }
    ]
  end
  ```

  This will generate a function `get_user(client, id)` that:
  1. Makes a JSON-RPC call to the "getUser" method
  2. Parses the response into a User struct
  The client argument is generated by JsonRpc.Client.WebSocket.start_link/2

  ## Method Configuration

  Each method in the list should be a map with the following keys:

  - Required keys:
    - `method`: The JSON-RPC method name (string)
    - `doc`: Documentation for the generated function.
    - `response_type`: The type specification for the response.
    - `response_parser`: A function that parses the raw response into the desired type. Is only
      called if the RPC call is successful. If should return `{:ok, any()}` or `{:error, any()}`.

  - Optional keys:
    - `retries`: The number of times to retry the request if it fails (defaults to
      #{@default_retries})
    - `timeout`: The maximum time to wait for a response in ms (defaults to #{@default_timeout})
    - `retry_on_timeout?`: Defines whether to retry the request after a timeout (do not set to true
      on something like an ethereum transaction as it might duplicate the transaction if the first
      request went through, but was simply slow to respond) (defaults to
      #{@default_retry_on_timeout?})
    - `time_between_retries`: The time to wait between retries in ms (If retry_on_timeout? is true
      we first wait for the request to timeout, then wait for time_between_retries, and finally
      retry the request) (defaults to #{@default_time_between_retries})
    - `args`: A list of `{arg_name, type}` tuples defining the function arguments.
    - `args_transformer!`: A function that transforms the arguments into the format expected by the
      RPC call (can also be used to validate the arguments). This argument is required only if
      `args` is provided.

  ## Options
  The macro also generates a type `options` that can be used to override the default behavior of the
  functions. The options can include:

  - `:retries`: Number of retries
  - `:timeout`: Timeout in milliseconds
  - `:retry_on_timeout?`: Whether to retry on timeout
  - `:time_between_retries`: Time to wait between retries in milliseconds


  ## Debug Mode

  You can enable debug mode by using the `:debug` option:

  ```elixir
  use JsonRpc.ApiCreator, {:debug, [...]}
  ```
  This will print the generated code to the console during compilation.

  ## Example

  ```elixir
  defmodule UserApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        response_type: User.t(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            %{id: id}
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      },
      %{
        method: "listUsers",
        doc: "Lists all users",
        retries: 2,
        timeout: :timer.seconds(5)
        retry_on_timeout?: true,
        time_between_retries: 200,
        response_type: [User.t()],
        response_parser: fn
          response when is_list(response) -> {:ok, Enum.map(response, &User.parse/1)}
          _ -> {:error, "Invalid response"}
        end
      }
    ]
  end

  # Usage:

  {:ok, client} = JsonRpc.Client.WebSocket.start_link("ws://localhost:4242")

  UserApi.get_user(client, "123") # Returns {:ok, %User{}} or {:error, reason}
  UserApi.list_users(client)    # Returns {:ok, [{:ok, %User{}}, ...]} or {:error, reason}

  UserApi.get_user(client, "123", timeout: 3000, retries: 4) # override timeout and retries
  ```
  """

  defmacro __using__({:debug, methods}) do
    methods
    |> List.wrap()
    |> Enum.map(&generate_ast(&1))
    |> then(&[option_type_ast() | &1])
    |> print_debug_code(__CALLER__.module)
  end

  defmacro __using__(methods) do
    methods
    |> List.wrap()
    |> Enum.map(&generate_ast(&1))
    |> then(&[option_type_ast() | &1])
  end

  defp option_type_ast() do
    quote do
      @type options :: [
              {:retries, non_neg_integer()}
              | {:timeout, non_neg_integer()}
              | {:retry_on_timeout?, boolean()}
              | {:time_between_retries, non_neg_integer()}
            ]
    end
  end

  defp generate_ast({:%{}, _, opts}) do
    %{
      method: method,
      doc: doc,
      response_type: response_type,
      response_parser: response_parser
    } = opts = Enum.into(opts, %{})

    args = Map.get(opts, :args, []) |> List.wrap()
    args_spec = Enum.map(args, fn {arg, type} -> quote do: unquote(arg) :: unquote(type) end)
    args = Enum.map(args, fn {arg, _type} -> arg end)
    args_transformer! = get_args_transformer!(args, opts, method)
    timeout = Map.get(opts, :timeout, @default_timeout)
    retries = Map.get(opts, :retries, @default_retries)
    retry_on_timeout? = Map.get(opts, :retry_on_timeout?, @default_retry_on_timeout?)
    time_between_retries = Map.get(opts, :time_between_retries, @default_time_between_retries)

    func_name = method |> to_snake_case() |> String.to_atom()
    do_func_name = :"do_#{func_name}"

    quote do
      @doc unquote(doc)
      @spec unquote(func_name)(WebSockex.client(), unquote_splicing(args_spec), options()) ::
              {:ok, unquote(response_type)}
              | {:error, :connection_closed | :timeout | JsonRpc.Response.Error.t() | any()}
      def unquote(func_name)(client, unquote_splicing(args), opts \\ []) do
        unquote(do_func_name)(
          client,
          unquote_splicing(args),
          Keyword.get(opts, :timeout, unquote(timeout)),
          Keyword.get(opts, :retries, unquote(retries)),
          Keyword.get(opts, :retry_on_timeout?, unquote(retry_on_timeout?)),
          Keyword.get(opts, :time_between_retries, unquote(time_between_retries))
        )
      end

      defp unquote(do_func_name)(
             client,
             unquote_splicing(args),
             timeout,
             retries,
             retry_on_timeout?,
             time_between_retries
           ) do
        result =
          unquote(
            if args != [] do
              quote do
                JsonRpc.Client.WebSocket.call_with_params(
                  client,
                  unquote(method),
                  unquote(args_transformer!).(unquote_splicing(args)) |> List.wrap(),
                  timeout
                )
              end
            else
              quote do
                JsonRpc.Client.WebSocket.call_without_params(
                  client,
                  unquote(method),
                  timeout
                )
              end
            end
          )

        case result do
          {:ok, raw_response_result} ->
            # This pattern is only true if the response is neither :connection_closed nor :timeout
            with {:ok, raw_response} <- raw_response_result,
                 do: unquote(response_parser).(raw_response)

          {:error, reason} ->
            if retries > 0 && (reason != :timeout || retry_on_timeout?) do
              Process.sleep(time_between_retries)

              unquote(do_func_name)(
                client,
                unquote_splicing(args),
                timeout,
                retries - 1,
                retry_on_timeout?,
                time_between_retries
              )
            else
              {:error, reason}
            end
        end
      end
    end
  end

  defp get_args_transformer!(args, opts, method) do
    if args != [] do
      Map.get(opts, :args_transformer!) ||
        throw("Missing key :args_transformer! for method #{method}")
    else
      :nop
    end
  end

  defp print_debug_code(ast, module) do
    readable_code = ast |> Macro.to_string() |> Code.format_string!() |> IO.iodata_to_binary()
    IO.puts("Generated code for module #{module} #{readable_code}")

    ast
  end

  defp to_snake_case(str) do
    str
    |> String.replace(
      # Find a lowercase letter followed by an uppercase letter
      ~r/([a-z])([A-Z])/,
      # Replace with the lowercase letter, an underscore, and the uppercase letter
      "\\1_\\2"
    )
    |> String.downcase()
  end
end
