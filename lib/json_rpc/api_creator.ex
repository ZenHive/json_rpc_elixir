defmodule JsonRpc.ApiCreator do
  # TODO update the docs

  import JsonRpc.ApiCreator.Dsl,
    only: [
      default_retries: 0,
      default_timeout: 0,
      default_retry_on_timeout?: 0,
      default_time_between_retries: 0
    ]

  @moduledoc """
  ## Description

  Defines a use macro for creating JSON-RPC APIs by automatically generating functions
  that map to JSON-RPC methods. It handles the boilerplate of making RPC calls and
  parsing responses.

  ## Basic Usage

  ```elixir
  defmodule MyApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        retries: 2,
        timeout: :timer.seconds(5)
        retry_on_timeout?: false,
        time_between_retries: 200,
        response_type: User.t(),
        parsing_error_type: User.parsing_error(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            [id]
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      }
    ]
  end
  ```

  This will generate a function `get_user(client, id)` that:
  1. Makes a JSON-RPC call to the "getUser" method
  2. Parses the response into a User struct
  The client argument is generated by JsonRpc.Client.WebSocket.start_link/2

  ## Method Configuration

  Each method in the list should be a map with the following keys:

  - Required keys:
    - `method`: The JSON-RPC method name (string)
    - `doc`: Documentation for the generated function.
    - `response_type`: The type specification for the response.
    - `parsing_error_type`: The type specification for the response.
    - `response_parser`: A function that parses the raw response into the desired type. Is only
      called if the RPC call is successful. If should return `{:ok, response_type()}` or
      `{:error, any()}`.

  - Optional keys:
    - `retries`: The number of times to retry the request if it fails (defaults to
      #{default_retries()})
    - `timeout`: The maximum time to wait for a response in ms (defaults to #{default_timeout()})
    - `retry_on_timeout?`: Defines whether to retry the request after a timeout (do not set to true
      on something like an ethereum transaction as it might duplicate the transaction if the first
      request went through, but was simply slow to respond) (defaults to
      #{default_retry_on_timeout?()})
    - `time_between_retries`: The time to wait between retries in ms (If retry_on_timeout? is true
      we first wait for the request to timeout, then wait for time_between_retries, and finally
      retry the request) (defaults to #{default_time_between_retries()})
    - `args`: A list of `{arg_name, type}` tuples defining the function arguments. `arg_name`
      MUST NOT start with `__` as this is reserved for internal use.
    - `args_transformer!`: A function that transforms the arguments into the format expected by the
      RPC call (can also be used to validate the arguments). This argument is required only if
      `args` is provided.

  ## Options
  The macro also generates a type `options` that can be used to override the default behavior of the
  functions. The options can include:

  - `:retries`: Number of retries
  - `:timeout`: Timeout in milliseconds
  - `:retry_on_timeout?`: Whether to retry on timeout
  - `:time_between_retries`: Time to wait between retries in milliseconds


  ## Debug Mode

  You can enable debug mode by using the `:debug` option:

  ```elixir
  use JsonRpc.ApiCreator, {:debug, [...]}
  ```
  This will print the generated code to the console during compilation.

  ## Example

  ```elixir
  defmodule UserApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        response_type: User.t(),
        parsing_error_type: User.parsing_error(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            # You could also return id (When you don't return a list we automatically wrap it in a
            # list)
            [id]
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      },
      %{
        method: "listUsers",
        doc: "Lists all users",
        retries: 2,
        timeout: :timer.seconds(5)
        retry_on_timeout?: true,
        time_between_retries: 200,
        response_type: [{:ok, User.t()} | {:error, User.parsing_error()}],
        parsing_error_type: :invalid_response,
        response_parser: fn
          response when is_list(response) -> {:ok, Enum.map(response, &User.parse/1)}
          _ -> {:error, :invalid_response}
        end
      }
    ]
  end

  # Usage:

  {:ok, client} = UserApi.start_link("ws://localhost:4242")

  UserApi.get_user(client, 42)
  # Makes a JSON-RPC call with the following data:
  # {
  #   "jsonrpc": "2.0",
  #   "method": "getUser",
  #   "params": {"id": "id_42"},
  #   "id": 1
  # }
  # Returns the following:
  # {:ok, User.t()} | {:error, UserApi.get_user_error()}

  UserApi.list_users(client)
  # Makes a JSON-RPC call with the following data:
  # {
  #   "jsonrpc": "2.0",
  #   "method": "listUsers",
  #   "id": 2
  # }
  # Returns the following:
  # {:ok, [{:ok, User.t()} | {:error, User.parsing_error()}]} | {:error, UserApi.list_users_error()}

  # override timeout and retries
  UserApi.get_user(client, 42, timeout: 3000, retries: 4)
  ```
  """
  use Spark.Dsl,
    default_extensions: [
      extensions: [__MODULE__.Dsl]
    ]
end
