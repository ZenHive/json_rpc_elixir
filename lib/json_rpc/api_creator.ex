defmodule JsonRpc.ApiCreator do
  import JsonRpc.ApiCreator.Dsl,
    only: [
      default_retries: 0,
      default_timeout: 0,
      default_retry_on_timeout?: 0,
      default_time_between_retries: 0
    ]

  @moduledoc """
  Defines a use macro for creating JSON-RPC APIs by automatically generating functions
  that map to JSON-RPC methods. It handles the boilerplate of making RPC calls and
  parsing responses.

  ## Basic Usage

  ```elixir
  defmodule MyApi do
    use JsonRpc.ApiCreator

    methods do
      method "getUser" do
        doc "Fetches a user by ID"
        retries 2
        timeout :timer.seconds(5)
        retry_on_timeout? false
        time_between_retries 200
        response_type User.t()
        parsing_error_type User.parsing_error()
        response_parser &User.parse/1
        args [{id, integer()}]

        args_transformer! fn id ->
          if is_integer(id) do
            [id]
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      end
    end
  end
  ```

  This will generate a function `MyApi.get_user(client, id)` that:
  1. Makes a JSON-RPC call to the "getUser" method
  2. Parses the response into a User struct
  The client argument is generated by MyApi.start_link/2

  ## Method Configuration

  Each method should be defined within the `methods` block using the `method` macro.

  ```elixir
  methods do
    method "JSON-RPC method name" do
      # ... keys (see below)
    end

    # ... other methods
  end
  ```

  - Required keys:
    - `doc`: Documentation for the generated function or false (false has the same effect as
      `@doc false`).
    - `response_type`: The type specification for the response on success.
    - `parsing_error_type`: The type specification for the response_parser error.
    - `response_parser`: A function that parses the raw response into the desired type. Is only
      called if the RPC call is successful. If should return `{:ok, response_type()}` or
      `{:error, any()}`.

  - Optional keys:
    - `retries`: The number of times to retry the request if it fails (defaults to
      #{default_retries()})
    - `timeout`: The maximum time to wait for a response in ms (defaults to #{default_timeout()})
    - `retry_on_timeout?`: Defines whether to retry the request after a timeout (do not set to true
      on something like an ethereum transaction as it might duplicate the transaction if the first
      request went through, but was simply slow to respond) (defaults to
      #{default_retry_on_timeout?()})
    - `time_between_retries`: The time to wait between retries in ms (If retry_on_timeout? is true
      we first wait for the request to timeout, then wait for time_between_retries, and finally
      retry the request) (defaults to #{default_time_between_retries()})
    - `args`: A list of `{arg_name, type}` tuples defining the function arguments. `arg_name`
      MUST NOT start with `__` as this is reserved for internal use.
    - `args_transformer!`: A function that transforms the arguments into the format expected by the
      RPC call (can also be used to validate the arguments). This argument is required only if
      `args` is provided.

  ## Options
  The macro also generates a type `options` that can be used to override the default behavior of the
  functions. The options can include:

  - `:retries`: Number of retries
  - `:timeout`: Timeout in milliseconds
  - `:retry_on_timeout?`: Whether to retry on timeout
  - `:time_between_retries`: Time to wait between retries in milliseconds


  ## Example

  ```elixir
  defmodule UserApi do
    use JsonRpc.ApiCreator

    methods do
      method "getUser" do
        doc "Fetches a user by ID"
        response_type User.t()
        parsing_error_type User.parsing_error()
        response_parser &User.parse/1
        args [{id, integer()}]

        args_transformer! fn
          id when is_integer(id) -> id # When you don't return a list we automatically wrap it
          _ -> raise ArgumentError, "id must be an integer"
        end
      end

      method "listUsers" do
        doc "Lists all users"
        retries 2
        timeout :timer.seconds(5)
        retry_on_timeout? true
        time_between_retries 200
        response_type [User.t()]
        parsing_error_type :invalid_response

        response_parser fn
          response when is_list(response) ->
            Enum.reduce_while(response, {:ok, []}, fn item, {:ok, acc} ->
              case User.parse(item) do
                {:ok, user} -> {:cont, {:ok, [user | acc]}}
                {:error, _} = err -> {:halt, err}
              end
            end)

          _ ->
            {:error, :invalid_response}
        end
      end
    end
  end

  # Usage:

  {:ok, client} = UserApi.start_link("ws://localhost:4242")

  UserApi.get_user(client, 42)
  # Makes a JSON-RPC call with the following data:
  # {
  #   "jsonrpc": "2.0",
  #   "method": "getUser",
  #   "params": [42],
  #   "id": 1
  # }
  # Returns the following:
  # {:ok, User.t()} | {:error, UserApi.get_user_error()}

  UserApi.list_users(client)
  # Makes a JSON-RPC call with the following data:
  # {
  #   "jsonrpc": "2.0",
  #   "method": "listUsers",
  #   "id": 2
  # }
  # Returns the following:
  # {:ok, [User.t()]} | {:error, UserApi.list_users_error()}

  # override timeout and retries
  UserApi.get_user(client, 42, timeout: 3000, retries: 4)
  ```

  ## Formatting
  Add the following to your `.formatter.exs`:
  ```elixir
  import_deps: [:json_rpc],
  ```

  ## Custom frame handler
  If the API you are working with sends frames that are not responses to requests (e.g. ethereum
  subscriptions) you can define a function `unrecognized_frame_handler/1` in your module to handle
  those frames.

  ```elixir
  def unrecognized_frame_handler(frame) do
    # Handle the frame (e.g. send it to a process, log it, etc.)
    IO.inspect(frame, label: "Unrecognized frame")

    # Return value is ignored
    :ok
  end
  ```

  Only frames that are not recognized as responses to requests will be passed to this function.

  The unrecognized frame handler can also be replaced by passing the `:unrecognized_frame_handler`
  option to start_link/2.

  ```elixir
  {:ok, client} = MyApi.start_link("ws://localhost", unrecognized_frame_handler: &my_handler/1)
  ```

  ---
  ## The rest of this documentation was generated automatically and may be ignored
  """
  use Spark.Dsl,
    default_extensions: [
      extensions: [__MODULE__.Dsl]
    ]
end
