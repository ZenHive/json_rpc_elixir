defmodule JsonRpc.ApiCreator do
  @default_retries 2
  @default_timeout 5_000

  @moduledoc """
  ## Description

  Defines a use macro for creating JSON-RPC APIs by automatically generating functions
  that map to JSON-RPC methods. It handles the boilerplate of making RPC calls and
  parsing responses.

  ## Basic Usage

  ```elixir
  defmodule MyApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        retries: 2,
        timeout: :timer.seconds(5)
        response_type: User.t(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            %{id: id}
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      }
    ]
  end
  ```

  This will generate a function `get_user(client, id)` that:
  1. Makes a JSON-RPC call to the "getUser" method
  2. Parses the response into a User struct
  The client argument is generated by JsonRpc.Client.WebSocket.start_link/2

  ## Method Configuration

  Each method in the list should be a map with the following keys:

  - `method`: The JSON-RPC method name (string)
  - `doc`: Documentation for the generated function.
  - `response_type`: The type specification for the response.
  - `response_parser`: A function that parses the raw response into the desired type. Is only called
    if the RPC call is successful. If should return `{:ok, any()}` or `{:error, any()}`.
  - `retries`: The number of times to retry the request if it fails (is optional, defaults to
    #{@default_retries})
  - `timeout`: The maximum time to wait for a response in ms (is optional, defaults to
    #{@default_timeout})
  - `args`: A list of `{arg_name, type}` tuples defining the function arguments.
    This argument is optional.
  - `args_transformer!`: A function that transforms the arguments into the format expected by the
    RPC call (can also be used to validate the arguments). This argument is required only if `args`
    is provided.

  ## Debug Mode

  You can enable debug mode by using the `:debug` option:

  ```elixir
  use JsonRpc.ApiCreator, {:debug, [...]}
  ```
  This will print the generated code to the console during compilation.

  ## Example

  ```elixir
  defmodule UserApi do
    use JsonRpc.ApiCreator, [
      %{
        method: "getUser",
        doc: "Fetches a user by ID",
        response_type: User.t(),
        response_parser: &User.parse/1,
        args: [{id, integer()}],
        args_transformer!: fn id ->
          if is_integer(id) do
            %{id: id}
          else
            raise ArgumentError, "id must be an integer"
          end
        end
      },
      %{
        method: "listUsers",
        doc: "Lists all users",
        retries: 2,
        timeout: :timer.seconds(5)
        response_type: [User.t()],
        response_parser: fn
          response when is_list(response) -> {:ok, Enum.map(response, &User.parse/1)}
          _ -> {:error, "Invalid response"}
        end
      }
    ]
  end

  # Usage:

  {:ok, client} = JsonRpc.Client.WebSocket.start_link("ws://localhost:4242")

  UserApi.get_user(client, "123") # Returns {:ok, %User{}} or {:error, reason}
  UserApi.list_users(client)    # Returns {:ok, [{:ok, %User{}}, ...]} or {:error, reason}

  UserApi.get_user(client, "123", timeout: 3000, retries: 4) # override timeout and retries
  ```
  """

  defmacro __using__({:debug, methods}) do
    methods
    |> List.wrap()
    |> Enum.map(&generate_ast(&1))
    |> print_debug_code(__CALLER__.module)
  end

  defmacro __using__(methods) do
    methods
    |> List.wrap()
    |> Enum.map(&generate_ast(&1))
  end

  defp generate_ast({:%{}, _, opts}) do
    %{
      method: method,
      doc: doc,
      response_type: response_type,
      response_parser: response_parser
    } = opts = Enum.into(opts, %{})

    args = Map.get(opts, :args, []) |> List.wrap()
    args_spec = Enum.map(args, fn {arg, type} -> quote do: unquote(arg) :: unquote(type) end)
    args = Enum.map(args, fn {arg, _type} -> arg end)
    args_transformer! = get_args_transformer!(args, opts, method)
    timeout = Map.get(opts, :timeout, @default_timeout)
    retries = Map.get(opts, :retries, @default_retries)

    func_name = method |> to_snake_case() |> String.to_atom()
    do_func_name = :"do_#{func_name}"

    quote do
      @doc unquote(doc)
      @spec unquote(func_name)(
              WebSockex.client(),
              unquote_splicing(args_spec),
              opts :: [{:retries, non_neg_integer()} | {:timeout, non_neg_integer()}]
            ) ::
              Result.t(
                unquote(response_type),
                :connection_closed | :timeout | JsonRpc.Response.Error.t() | any()
              )
      def unquote(func_name)(client, unquote_splicing(args), opts \\ []) do
        unquote(do_func_name)(
          client,
          unquote_splicing(args),
          Keyword.get(opts, :timeout, unquote(timeout)),
          Keyword.get(opts, :retries, unquote(retries))
        )
      end

      defp unquote(do_func_name)(client, unquote_splicing(args), timeout, retries) do
        result =
          unquote(
            if args != [] do
              quote do
                JsonRpc.Client.WebSocket.call_with_params(
                  client,
                  unquote(method),
                  unquote(args_transformer!).(unquote_splicing(args)) |> List.wrap(),
                  timeout
                )
              end
            else
              quote do
                JsonRpc.Client.WebSocket.call_without_params(
                  client,
                  unquote(method),
                  timeout
                )
              end
            end
          )

        case result do
          {:ok, raw_response_result} ->
            # This pattern is only true if the response is neither :connection_closed nor :timeout
            with {:ok, raw_response} <- raw_response_result,
                 do: unquote(response_parser).(raw_response)

          error ->
            if retries > 0 do
              unquote(do_func_name)(client, unquote_splicing(args), timeout, retries - 1)
            else
              error
            end
        end
      end
    end
  end

  defp get_args_transformer!(args, opts, method) do
    if args != [] do
      Map.get(opts, :args_transformer!) ||
        throw("Missing key :args_transformer! for method #{method}")
    else
      :nop
    end
  end

  defp print_debug_code(ast, module) do
    readable_code = ast |> Macro.to_string() |> Code.format_string!() |> IO.iodata_to_binary()
    IO.puts("Generated code for module #{module} #{readable_code}")

    ast
  end

  defp to_snake_case(str) do
    str
    |> String.replace(
      # Find a lowercase letter followed by an uppercase letter
      ~r/([a-z])([A-Z])/,
      # Replace with the lowercase letter, an underscore, and the uppercase letter
      "\\1_\\2"
    )
    |> String.downcase()
  end
end
